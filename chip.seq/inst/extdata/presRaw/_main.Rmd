---
title: "ChIPseq In Bioconductor <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/RU_ChIPseq/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---

```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
```

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# ChIPseq (part 1)

---
"    
  )
  
}

```

```{r setup2, include=FALSE,eval=FALSE,echo=FALSE}
library(ShortRead)

fqSample <- FastqSampler("~/Downloads/ENCFF001NQP.fastq.gz",n=10^6)
temp <- yield(fqSample)


writeFastq(fastqSample,file = "~/Projects/Software/Github/RUBioconductor_Introduction/r_course/Data/sampled_ENCFF000CXH.fastq.gz",mode = "w")
```

## ChIPseq introduction 

Chromatin precipitation followed by deep sequencing (**ChIPseq**) is a well established technique which allows for the genome wide identification of transcription factor binding sites and epigenetic marks. 

<div align="center">
<img src="imgs/chipOverview1.png" alt="igv" height="400" width="600">
</div>

---
## ChIPseq introduction 

.pull-left[
<div align="center">
<img src="imgs/chipOverview2.png" alt="igv" height="500" width="300">
</div>
]

.pull-right[

* Cross-linked and protein bound DNA.
* Enrichment by antibody for specific protein or DNA state.
* End repair, A-tailed and illumina adaptors added.
* Fragments sequenced from one/either end.
]
---
## The data

Our raw ChIPseq sequencing data will be in FASTQ format.

<div align="center">
<img src="imgs/fq1.png" alt="igv" height="200" width="600">
</div>


---
## The data

In this ChIPseq workshop we will be investigating the genome wide binding patterns of the transcription factor Myc in mouse MEL and Ch12 cell lines.

We can retrieve the raw sequencing data from Encode website.

Here we download the sequencing data for the Myc ChIPseq from the Mouse MEL cell line[, sample **ENCSR000EUA** (replicate 1), using the Encode portal.](https://www.encodeproject.org/experiments/ENCSR000EUA/)

The direct link to the raw sequecing reads in FastQ format can be found [here.](https://www.encodeproject.org/files/ENCFF001NQP/@@download/ENCFF001NQP.fastq.gz)

Download the fastQ for the other Myc MEL replicate from [sample ENCSR000EUA](https://www.encodeproject.org/experiments/ENCSR000EUA/). Direct link is [here](https://www.encodeproject.org/files/ENCFF001NQQ/@@download/ENCFF001NQQ.fastq.gz).


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Working with raw ChIPseq data

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Working with raw ChIPseq data

---
"    
  )
  
}

```

## Working with raw ChIPseq data

Once we have downloaded the raw fastQ data we can use the [ShortRead package](https://bioconductor.org/packages/release/bioc/html/ShortRead.html) to review our sequence data quality.

We have reviewed how to work with raw sequencing data in the [**FastQ in Bioconductor** session.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#1)

First we load the [ShortRead library.](https://bioconductor.org/packages/release/bioc/html/ShortRead.html)


```{r shortreada,include=FALSE}
library(ShortRead)

```

```{r shortread, warning=F, message=F}
library(ShortRead)
```

---
## Working with raw ChIPseq data

First we will review the raw sequencing reads using functions in the [ShortRead package.](https://bioconductor.org/packages/release/bioc/html/ShortRead.html) This is similar to our QC we performed for RNAseq. 

We do not need to review all reads in the file to can gain an understanding of data quality. We can simply review a subsample of the reads and save ourselves some time and memory.

Note when we subsample we retrieve random reads from across the entire fastQ file. This is important as fastQ files are often ordered by their position on the sequencer.

---
## Reading raw ChIPseq data

We can subsample from a fastQ file using functions in **ShortRead** package.

Here we use the [**FastqSampler** and **yield** function](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#41) to randomly sample a defined number of reads from a fastQ file. Here we subsample 1 million reads.

```{r, echo=F,eval=F}
fqSample <- FastqSampler("~/Downloads/ENCFF001NQP.fastq.gz",n=10^6)
fastq <- yield(fqSample)

writeFastq(fastq,file = "~/Documents/Box Sync/RU/Teaching/RU_side/RU_ChIPseq/chipseq/inst/extdata/data/sampled_ENCFF001NQP.fastq.gz",mode = "w")

```

```{r eval=T, echo=F}
fastq <- readFastq(dirPath = "data/sampled_ENCFF001NQP.fastq.gz")
```

```{r mycRep1Reads,echo=T,eval=F}
fqSample <- FastqSampler("~/Downloads/ENCFF001NQP.fastq.gz",n=10^6)
fastq <- yield(fqSample)
```

---
## Working with raw ChIPseq data

The resulting object is a [ShortReadQ object](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#10) showing information on the number of cycles, base pairs in reads, and number of reads in memory.

```{r mycRep1ReadsShortReadQ,cache=TRUE,dependson="mycRep1Reads"}
fastq
```

---

## Raw ChIPseq data QC

If we wished, we can assess information from the fastQ file using our [familiar accessor functions.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#15)

* **sread()** - Retrieve sequence of reads.
* **quality()** - Retrieve quality of reads as ASCI scores.
* **id()** - Retrieve IDs of reads.



```{r mycRep1ReadsAccessor,cache=TRUE,dependson="mycRep1Reads"}
readSequences <- sread(fastq)
readQuality <- quality(fastq)
readIDs <- id(fastq)
readSequences
```

---
## Quality with raw ChIPseq data

We can check some simple quality metrics for our subsampled fastQ data.

First, we can review the overall reads' quality scores.

We use the [**alphabetScore()** function with our read's qualitys](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#28) to retrieve the sum quality for every read from our subsample.



```{r mycRep1ReadsQScores,cache=TRUE,dependson="mycRep1Reads"}
readQuality <- quality(fastq)
readQualities <- alphabetScore(readQuality)
readQualities[1:10]
```

---

## Quality with raw ChIPseq data

We can then produce a histogram of quality scores to get a better understanding of the distribution of scores.

```{r mycRep1ReadsQScoresPlot,cache=TRUE,dependson="mycRep1ReadsQScores",fig.height=3,fig.width=8}
library(ggplot2)
toPlot <- data.frame(ReadQ=readQualities)
ggplot(toPlot,aes(x=ReadQ))+geom_histogram()+theme_minimal()
```


---

## Base frequency with raw ChIPseq data

We can review the occurrence of DNA bases within reads and well as the occurrence of DNA bases across sequencing cycles using the [**alphabetFrequency()**](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#18) and [**alphabetByCycle()**](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#30) functions respectively.

Here we check the overall frequency of **A, G, C, T and N (unknown bases)** in our sequence reads.

```{r mycRep1ReadsAlpFreq,cache=TRUE,dependson="mycRep1Reads"}
readSequences <- sread(fastq)
readSequences_AlpFreq <- alphabetFrequency(readSequences)
readSequences_AlpFreq[1:3,]
```


---

## Base frequency with raw ChIPseq data

Once we have the frequency of DNA bases in our sequence reads we can retrieve the sum across all reads.

```{r mycRep1ReadsAlpFreqSum,cache=TRUE,dependson="mycRep1ReadsAlpFreq"}
summed__AlpFreq  <- colSums(readSequences_AlpFreq)
summed__AlpFreq[c("A","C","G","T","N")]
```

---

## Assess by cycle with raw ChIPseq data

We can review DNA base occurrence by cycle using the [**alphabetByCycle()** function.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#30)

```{r mycRep1ReadsAlpByCycle,cache=TRUE,dependson="mycRep1ReadsAlpFreq"}
readSequences_AlpbyCycle <- alphabetByCycle(readSequences)
readSequences_AlpbyCycle[1:4,1:10]
```

---

## Assess by cycle with raw ChIPseq data

We often plot this to visualise the base occurrence over cycles to observe any bias.
First we arrange the base frequency into a data frame.

```{r mycRep1ReadsAlpByCyclePlot,cache=TRUE,dependson="mycRep1ReadsAlpFreq"}
AFreq <- readSequences_AlpbyCycle["A",]
CFreq <- readSequences_AlpbyCycle["C",]
GFreq <- readSequences_AlpbyCycle["G",]
TFreq <- readSequences_AlpbyCycle["T",]
toPlot <- data.frame(Count=c(AFreq,CFreq,GFreq,TFreq),
                     Cycle=rep(1:36,4),
                     Base=rep(c("A","C","G","T"),each=36))

```

---

## Assess by cycle with raw ChIPseq data

Now we can plot the frequencies using ggplot2

```{r mycRep1ReadsAlpByCyclePlot2,cache=TRUE,eval=FALSE,dependson="mycRep1ReadsAlpByCyclePlot",fig.height=4,fig.width=8}

ggplot(toPlot,aes(y=Count,x=Cycle,colour=Base))+geom_line()+
  theme_bw()
```

```{r mycRep1ReadsAlpByCyclePlot3,cache=TRUE,echo=FALSE,dependson="mycRep1ReadsAlpByCyclePlot",fig.height=4,fig.width=8}

ggplot(toPlot,aes(y=Count,x=Cycle,colour=Base))+geom_line()+ylim(150000,400000)+
  theme_bw()
```
---

## Assess by cycle with raw ChIPseq data

We can also assess mean read quality over cycles. This will allow us to identify whether there are any isses with quality dropping off over time.

For this we use the [**as(*read_quality*,"matrix")**](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#29) function first to translate our ASCI quality scores to numeric quality scores.

```{r mycRep1ReadsQByCycle,cache=TRUE,dependson="mycRep1ReadsAlpFreq"}
qualAsMatrix <- as(readQuality,"matrix")
qualAsMatrix[1:2,]
```

---

## Assess by cycle with raw ChIPseq data

We can now [visualise qualities across cycles using a boxplot.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/exercises/answers/fastq_answers.html)

```{r mycRep1ReadsQByCyclePlot,cache=TRUE,dependson="mycRep1ReadsQByCycle",fig.width=8,fig.height=4}
boxplot(qualAsMatrix[1:1000,])
```

---

## Assess by cycle with raw ChIPseq data

In this case the distribution of reads quality scores and read qualities over time look okay. We will often want to access fastQ samples together to see if any samples stick out by these metrics.

Here we observed a second population of low quality scores so will remove some reads with low quality scores and high unknown bases.



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Filtering data

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Filtering data

---
"    
  )
  
}

```


## Filtering data

We will want to conserve our memory usage to [allow us to deal with loading large files.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#40)

Here we set up a **FastqStreamer object** to read in 100000 reads at a time. 

```{r out,eval=FALSE}
fqStreamer <- FastqStreamer("~/Downloads/ENCFF001NQP.fastq.gz",
                            n=100000)
```

---

## Filtering data

Now we [loop through file](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#43), filter reads and [write out a FastQ](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/FastQInBioconductor.html#39) of our filtered reads.

We are filtering low quality reads and reads with many nonspecific (N) base calls. 

```{r out1,eval=FALSE}
TotalReads <- 0
TotalReadsFilt <- 0
while (length(fq <- yield(fqStreamer))>0) {
    TotalReads <- TotalReads+length(fq)
    filt1 <- fq[alphabetScore(fq) > 300 ]
    filt2 <- filt1[alphabetFrequency(sread(filt1))[,"N"] < 10]
    TotalReadsFilt <- TotalReadsFilt+length(filt2)
    writeFastq(filt2,"filtered_ENCFF001NQP.fastq.gz",mode="a")
}
```
```{r,echo=F,eval=T}
TotalReads<-25555179
TotalReadsFilt<-22864597

```
```{r out11,eval=T,echo=T}
TotalReads
TotalReadsFilt
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Aligning data

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Aligning data

---
"    
  )
  
}

```

---
## Aligning ChIPseq reads

Following assessment of read quality and any read filtering we applied, we will want to align our reads to the genome so as to identify any genomic locations showing enrichment for aligned reads above background.

Since ChIPseq reads will align continously against our reference genome we can use [our genomic aligners we have seen in previous sessions.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/r_course/presentations/slides/AlignmentInBioconductor.html#7) The resulting BAM file will contain aligned sequence reads for use in further analysis.

<div align="center">
<img src="imgs/sam2.png" alt="igv" height="200" width="600">
</div>

---
## Creating a reference genome

First we need to retrieve the sequence information for the genome of interest in [FASTA format](https://rockefelleruniversity.github.io/Genomic_Data/presentations/slides/GenomicsData.html#9)

We can use the [BSgenome libraries to retrieve the full sequence information.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/SequencesInBioconductor.html#4)

For the mouse mm10 genome we load the package **BSgenome.Mmusculus.UCSC.mm10**.

```{r fa1q, include=FALSE}
library(BSgenome.Mmusculus.UCSC.mm10)
```

```{r fa1, echo=TRUE}
library(BSgenome.Mmusculus.UCSC.mm10)
BSgenome.Mmusculus.UCSC.mm10
```

---
## Creating a reference genome

We will only use the major chromosomes for our analysis so we may exclude random and unplaced contigs.
Here we cycle through the major chromosomes and create a [**DNAStringSet** object from the retrieved sequences](https://rockefelleruniversity.github.io/Bioconductor_Introduction/r_course/presentations/slides/SequencesInBioconductor.html#17).

```{r fa2,cache=FALSE,echo=TRUE}
mainChromosomes <- paste0("chr",c(1:19,"X","Y","M"))
mainChrSeq <- lapply(mainChromosomes,
                     function(x)BSgenome.Mmusculus.UCSC.mm10[[x]])
names(mainChrSeq) <- mainChromosomes
mainChrSeqSet <- DNAStringSet(mainChrSeq)
mainChrSeqSet
```

---
# Creating a reference genome.

Now we have a **DNAStringSet** object we can use the [**writeXStringSet** to create our FASTA file of sequences to align to.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/SequencesInBioconductor.html#22)

```{r fa3, echo=TRUE,eval=FALSE}
writeXStringSet(mainChrSeqSet,
                "BSgenome.Mmusculus.UCSC.mm10.mainChrs.fa")
```


---
## Creating an Rsubread index 

We will be aligning using the **subjunc** algorithm from the folks behind subread. We can therefore use the **Rsubread** package. Before we attempt to align our fastq files, we will need to first build an index from our reference genome using the **buildindex()** function.

The [**buildindex()** function simply takes the parameters of our desired index name and the FASTA file to build index from.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/r_course/presentations/slides/AlignmentInBioconductor.html#14)

REMEMBER: Building an index is memory intensive and by default is set to 8GB. This may be too large for your laptop or Desktop. 

Luckily we did this for RNAseq, so hopefully you will already have a built index. 
```{r, echo=TRUE,eval=FALSE}
library(Rsubread)
buildindex("mm10_mainchrs","BSgenome.Mmusculus.UCSC.mm10.mainChrs.fa", 
           memory=8000,
           indexSplit=TRUE)

```


---
## Rsubread ChIPseq alignment

We can align our raw sequence data in fastQ format to the new FASTA file of our mm10 genome sequence using the **Rsubread** package. Specifically we will be using the **align** function as this utilizes the subread genomic alignment algorithm. 

The [**align()** function accepts arguments for the index to align to, the fastQ to align, the name of output BAM, the mode of alignment (rna or dna) and the phredOffset.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/AlignmentInBioconductor.html#15)

Note that here we set the phredOffset to be 64. Rsubread may get upset if we set this wrong.

```{r, echo=F, eval=F}
myMapped <- align("~/Documents/Box Sync/RU/Teaching/Compilation/Genomes_And_Datasets/mm10/mm10_mainchrs",
                    "filtered_ENCFF001NQP.fastq.gz",
                    output_format = "BAM",
                    output_file = "Myc_Mel_1.bam",
                    nthreads = 4)

```


```{r, echo=TRUE,eval=FALSE}

myMapped <- align("mm10_mainchrs",
                    "filtered_ENCFF001NQP.fastq.gz",
                    output_format = "BAM",
                    output_file = "Myc_Mel_1.bam",
                    type='dna',
                    phredOffset = 64,
                    nthreads = 4)

```

---
## Rbowtie2 ChIPseq alignment

One of the most well known group of alignment alogorthims are the Bowtie family. We can access Bowtie2 with the **Rbowtie2** package.

The **QuasR** package allows access to the original Bowtie aligner, but it is a little slow and memory hungry.

```{r sampleTabless1, echo=TRUE,eval=FALSE}
library(Rbowtie2)
```

---
## Rbowtie2 ChIPseq alignment

As with **Rsubread**, the **Rbowtie2** package requires us to first to create an index to align to.

We can do this using the **bowtie2_build()** function, specifying our FASTA file and desired name of index.

```{r bsgecdnoaame, echo=TRUE,eval=FALSE}
bowtie2_build(references="BSgenome.Mmusculus.UCSC.mm10.mainChrs.fa", 
                       bt2Index=file.path("BSgenome.Mmusculus.UCSC.mm10.mainChrs"))
```

---
## Rbowtie2 ChIPseq alignment

We can then align our fastq data using the **bowtie2()** function specifying our newly created index, the desired name of SAM output and an uncompressed fastq.

We will need to uncompress our fastq then first. Here we use the **remove** is FALSE settin to maintain original compressed fastQ

```{r bsgcdcenoaame, echo=TRUE,eval=FALSE}
library(R.utils)
gunzip("filtered_ENCFF001NQP.fastq.gz",
       remove=FALSE)

bowtie2(bt2Index = "BSgenome.Mmusculus.UCSC.mm10.mainChrs",
          samOutput = "ENCFF001NQP.sam",
          seq1 = "filtered_ENCFF001NQP.fastq")
```

---
# Rbowtie2 ChIPseq alignment

Since Rbowtie2 also outputs a SAM file, we would need to need to convert to a BAM file. We can do this with the **RSamtools** **asBam()** function.

```{r bsgenoaaxssme, echo=TRUE,eval=FALSE}
bowtieBam <- asBam("ENCFF001NQP.sam")
```


---
## Rbowtie2 ChIPseq alignment

An important consideration when using Rbowtie2 is its input and output of uncompressed files.

On the command line we may *stream* inputs to Rbowtie2, but in R this isnt an option (yet!)

We would need to make sure we delete any temporary files created (SAM and/or uncompressed FastQ) to avoid filling up our hard drives. We can delete files in R using the **unlink()** function.

```{r bsgxxxnoaaxssme, echo=TRUE,eval=FALSE}
unlink("ENCFF001NQP.sam")

```

---

## Sort and index reads

As before, we sort and index our files using the [**Rsamtools** packages **sortBam()** and **indexBam()** functions respectively.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/r_course/presentations/slides/AlignedDataInBioconductor.html#10)

The resulting sorted and indexed BAM file is now ready for use in external programs such as IGV as well as for further downstream analysis in R.

```{r sortindex, echo=TRUE,eval=FALSE}
library(Rsamtools)
sortBam("Myc_Mel_1.bam","SR_Myc_Mel_rep1")
indexBam("SR_Myc_Mel_rep1.bam")
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Mapped data

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Mapped data

---
"    
  )
  
}

```

---

## Mapped reads

Now we have the index for the BAM file, we can retrieve and plot the number of mapped reads using [the **idxstatsBam()** function.](https://rockefelleruniversity.github.io/Bioconductor_Introduction//presentations/slides/AlignedDataInBioconductor.html#16)

```{R, eval=F, echo=F}
mappedReads <- idxstatsBam("SR_Myc_Mel_1.bam")
save(mappedReads, file="data/idxstatsBam_MycMel.RData")
```


```{r mapped1, echo=TRUE,eval=FALSE}
mappedReads <- idxstatsBam("SR_Myc_Mel_rep1.bam")
TotalMapped <- sum(mappedReads[,"mapped"])
ggplot(mappedReads,aes(x=seqnames,y=mapped))+
  geom_bar(stat="identity")+coord_flip()
```

```{r mapped, echo=FALSE,eval=TRUE,fig.width=4,fig.height=4}
load("data/idxstatsBam_MycMel.RData")
TotalMapped <- sum(mappedReads[,"mapped"])
suppressPackageStartupMessages(library(ggplot2))
ggplot(mappedReads,aes(x=seqnames,y=mapped))+geom_bar(stat="identity")+coord_flip()
```

---
## Create a bigWig

We can also create a bigWig from our sorted, indexed BAM file to allow us to quickly review our data in IGV.

First we use the [**coverage()** function to create an **RLElist object** containing our coverage scores.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/Summarising_Scores_In_Bioconductor.html#13)

```{r coverage, echo=TRUE,eval=FALSE}
forBigWig <- coverage("SR_Myc_Mel_rep1.bam")
forBigWig
```

---

## Create a bigWig

We can now export our [**RLElist object** as a bigWig using the **rtracklayer** package's **export.bw()** function.](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/GenomicScores_In_Bioconductor.html#40)

```{r bw, echo=TRUE,eval=FALSE}
library(rtracklayer)
export.bw(forBigWig,con="SR_Myc_Mel_rep1.bw")
```


---
## Create a bigWig

We may wish to normalize our coverage to allow us to compare enrichment across samples.

We can use the [**weight** parameter in the **coverage()**](https://rockefelleruniversity.github.io/Bioconductor_Introduction/presentations/slides/Summarising_Scores_In_Bioconductor.html#20) to scale our reads to the number of mapped reads multiplied by a million (reads per million).

```{r weightedCover, echo=TRUE,eval=FALSE}
forBigWig <- coverage("SR_Myc_Mel_rep1.bam",
                      weight = (10^6)/TotalMapped)
forBigWig
export.bw(forBigWig,con="SR_Myc_Mel_rep1_weighted.bw")
```

---
# BAM and bigWig

![](imgs/chipBw.png)

---
## Time for an exercise!

Exercise on ChIPseq data can be found [here](../../exercises/exercises/chipseq_part1_exercise.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/chipseq_part1_answers.html)

R code for solutions can be found [here](../../exercises/answers/chipseq_part1_answers.R)



<!--chapter:end:ChIPseq_In_Bioconductor.Rmd-->

---
title: "ChIPseq In Bioconductor <html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/RU_ChIPseq/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---


```{r,include=FALSE}
suppressPackageStartupMessages(require(knitr))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
```

```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# ChIPseq (part 2)

---
"    
  )
  
}

```

## Data

In todays session we will continue to review the Myc ChIPseq we were working on in our last session.

This include Myc ChIPseq for MEL and Ch12 celllines as well as their input controls.

Information and files for the [Myc ChIPseq in MEL cell line can be found here](https://www.encodeproject.org/experiments/ENCSR000EUA/)

Information and files for the [Myc ChIPseq in Ch12 cell line can be found here](https://www.encodeproject.org/experiments/ENCSR000ERN/)

Input control can be found for [MEL cell line can be found here](https://www.encodeproject.org/experiments/ENCSR000ADN/)

Input control can be found for [Ch12 cell line can be found here.](https://www.encodeproject.org/experiments/ENCSR000ERS/)


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Quality Control

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Quality Control

---
"    
  )
  
}

```

## Quality Control


ChIPseq has many sources of potential noise including 
* Varying efficiency of antibodies
* Non-specific binding
* Library complexity
* ChIP artefacts and background

Many of these sources of noise can be assessed using some well established methodology.

---

# Quality Control References 

For some discussions:

* Encode quality metrics.

[Large-scale quality analysis of published ChIPseq data. Marinov GK, Kundaje A, Park PJ, Wold BJ. G3 (Bethesda). 2014 Feb 19;4(2)](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3931556/)

* Overestimation of artefact duplicates in ChIPseq.

[Systematic evaluation of factors influencing ChIPseq fidelity.Nat Methods. Chen Y, Negre N, Li Q, Mieczkowska JO, Slattery M, Liu T, Zhang Y, Kim TK, He HH, Zieba J, Ruan Y, Bickel PJ, Myers RM, Wold BJ, White KP, Lieb JD, Liu XS. 2012 Jun;9(6)](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3477507/)


* When and what QC is useful.

[Impact of artifact removal on ChIP quality metrics in ChIPseq and ChIP-exo data.Front Genet. 2014 Apr 10;5:75.Carroll TS, Liang Z, Salama R, Stark R, de Santiago I](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3989762/)

---
## Always have an appropriate input


* Input samples are typically made from fragmented DNA prior to IP enrichment.

* Allows for control of artefact regions which occur across samples.

* NEVER run ChIPseq without considering which input to use.

e.g. When using tumour samples for ChIPseq, it is important to have matched input samples. 
Differing conditions of same tissue may share common input. 

---
## Quality metrics for ChIPseq


The [**ChIPQC package**](https://bioconductor.org/packages/release/bioc/html/ChIPQC.html) wraps some of the metrics into a Bioconductor package and takes care to measure these metrics under the appropriate condition. 

To run a single sample we can use the **ChIPQCsample()** function, the relevant **unfiltered** BAM file and we are recommended to supply a **blacklist** as a BED file or GRanges and Genome name.

You can find a Blacklist for most genomes at [Anshul Kundaje's site](https://sites.google.com/site/anshulkundaje/projects/blacklists) or directly from the [Encode websites](https://www.encodeproject.org/annotations/ENCSR636HFF/)

```{r mycQCdwdwshowL,include=FALSE}
library(ChIPQC)
```


```{r,eval=F} 
QCresult <- ChIPQCsample(reads="/pathTo/myChIPreads.bam",
                         genome="mm10",
                         blacklist = "/pathTo/mm10_Blacklist.bed")
```

---
## Quality control with ChIPQC

We download the blacklist for mm10 from [Encode ](https://www.encodeproject.org/files/ENCFF547MET/@@download/ENCFF547MET.bed.gz)

We can then provide an initial analysis of our ChIPseq samples quality using the **ChIPQCsample()** function from the [**ChIPQC** package.](http://bioconductor.org/packages/stats/bioc/ChIPQC/).

Here we evalute the quality of samples we aligned with Rsubread last week. The returned object is a **ChIPQCsample** object.

```{r mycQC,cache=TRUE,eval=FALSE}
library(ChIPQC)
toBlkList<-"~/Downloads/ENCFF547MET.bed.gz"
chipqc_MycMel_rep1 <- ChIPQCsample("SR_Myc_Mel_rep1.bam",
                         annotation = "mm10",
                         blacklist = toBlkList,
                         chromosomes = paste0("chr",1:10))
class(chipqc_MycMel_rep1)

```



```{r mycQCsecret,eval=FALSE,echo=F}
library(ChIPQC)
toBlkList<-"~/Documents/Box Sync/RU/Teaching/Compilation/Genomes_And_Datasets/mm10/ENCFF547MET.bed.gz"
chipqc_MycMel_rep1 <- ChIPQCsample("SR_Myc_Mel_rep1.bam",
                         annotation = "mm10",
                         blacklist = toBlkList,
                         chromosomes = paste0("chr",1:10))
save(chipqc_MycMel_rep1,file='~/Documents/Box Sync/RU/Teaching/RU_side/RU_ChIPseq/chipseq/inst/extdata/data/rep1.RData')
```

```{r mycQCshowLa,echo=FALSE,eval=TRUE}
toBlkList<-"data/ENCFF547MET.bed.gz"
library(ChIPQC)
load(file='data/rep1.RData')
class(chipqc_MycMel_rep1)
```

---
## Quality control with ChIPQC

We can display our **ChIPQCsample** object which will show a basic summary of our ChIPseq quality.

```{r mycQCshow,eval=TRUE}
chipqc_MycMel_rep1
```

---
## QC of multiple samples

It is best to review ChIPseq quality versus your input controls and other Myc samples which we are using (or even external data if you do not have your own).

This will allow us to identify expected patterns of ChIPseq enrichment in our samples versus controls as well as spot any outlier samples by these metrics.

We can run **ChIPQCsample()** on all our samples of interest using an **lapply**.

```{r, echo=F, eval=F}
FQ_FILES<-paste0("~/Documents/Box Sync/RU/Teaching/Compilation/Genomes_And_Datasets/ChIPseq_course/",c("ENCFF001NQP.fastq.gz","ENCFF001NQP.fastq.gz","ENCFF001NGC.fastq.gz","ENCFF001NGO.fastq.gz","ENCFF001NCH.fastq.gz","ENCFF001NCF.fastq.gz","ENCFF001NIM.fastq.gz"))

FQ_NAMES<-c("Myc_Mel_1.bam","Myc_Mel_2.bam","Myc_Ch12_1.bam","Myc_Ch12_2.bam","input_Mel_1.bam","input_Mel_2.bam","input_Ch12_1.bam")

myMapped <- align("~/Documents/Box Sync/RU/Teaching/Compilation/Genomes_And_Datasets/mm10/mm10_mainchrs",
                    FQ_FILES,
                    output_format = "BAM",
                    output_file = FQ_NAMES,
                    nthreads = 4)

library(Rsamtools)
library(stringr)

SR_FQ_NAMES<-paste0("SR_",FQ_NAMES)
SR_FQ_NAMES_1<-paste0("SR_",str_split(FQ_NAMES,".bam", simplify = T)[,1])

bplapply(1:length(SR_FQ_NAMES), function(x){
sortBam(FQ_NAMES[x], SR_FQ_NAMES_1[x])
indexBam(SR_FQ_NAMES[x])
})

```

```{r mycQCshowd2,cache=TRUE,eval=FALSE,include=FALSE, echo=F}
FQ_NAMES<-c("Myc_Mel_1.bam","Myc_Mel_2.bam","Myc_Ch12_1.bam","Myc_Ch12_2.bam","input_Mel_1.bam","input_Mel_2.bam","input_Ch12_1.bam")
SR_FQ_NAMES<-paste0("SR_",FQ_NAMES)
bamsToQC <- SR_FQ_NAMES
myQC <- bplapply(bamsToQC,ChIPQCsample,
        annotation = "mm10",
        blacklist = toBlkList,
        chromosomes = paste0("chr",1:10))
names(myQC)<-bamsToQC
save(myQC, file="data/myQCnoPeaks.RData")
# tried to update, but ChIPQC is upset. so leave it for now and owrk with old chipqc object
```

```{r mycQCshow2,cache=TRUE,eval=FALSE}
bamsToQC <- c("Sorted_Myc_Ch12_1.bam","Sorted_Myc_Ch12_2.bam",
             "Sorted_Myc_MEL_1.bam","Sorted_Myc_MEL_2.bam",
             "Sorted_Input_MEL.bam","Sorted_Input_Ch12.bam")
myQC <- bplapply(bamsToQC,ChIPQCsample,
        annotation = "mm10",
        blacklist = toBlkList,
        chromosomes = paste0("chr",1:10))
names(myQC) <- bamsToQC
```

---
## QC of multiple samples

All ChIPQC functions can work with a named list of **ChIPQCsample** objects to aggregate scores into table as well as plots.

Here we use the **QCmetrics()** function to give an overview of quality metrics. 

```{r qcmetricsA,include=FALSE}
load(file="data/myQCnoPeaks.RData")
```

```{r qcmetrics,cache=FALSE,eval=TRUE}
QCmetrics(myQC)
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Assessing fragment length

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Assessing fragment length

---
"    
  )
  
}

```

## Assessing fragment length

The prediction of fragment length is an essential part of ChIPseq affecting peaks calling, summit identification and coverage profiles. 

The use of cross-correlation or cross-coverage allows for an assessment of reads clustering by strand and so a measure of quality. 

---
## Assessing fragment length

<div align="center">
<img src="imgs/ChIP-seq_biology_slides.png" alt="offset" height="400" width="600">
</div>

---

## Assessing fragment length

* In ChIPseq typically short single end reads of dsDNA.

* **dsDNA single end sequencing means**
+ 5' of fragment will be sequenced on "+" strand
+ 3' of fragment end will be on "-" strand.

* **Although we only have partial sequence of strand, with predicted fragment length we can predicted the whole fragment**
+ "+" reads should extend only in positive direction 
+ "-" reads only in negative

---

## Assessing fragment length

<div align="center">
<img src="imgs/pileup.png" alt="offset" height="500" width="400">
</div>

---

## Assessing fragment length

<div align="center">
<img src="imgs/offset.jpg" alt="offset" height="500" width="400">
</div>

---

## Assessing fragment length

<div align="center">
<img src="imgs/shifts.gif" alt="offset" height="200" width="700">
</div>
<div align="center">
<img src="imgs/cor.gif" alt="offset" height="300" width="700">
</div>

---

## Cross-coverage plot 

<div align="center">
<img src="imgs/shifts.jpg" alt="offset" height="500" width="400">
</div>

---

## Cross-coverage plot
The **plotCC** function can be used to plot our cross-coverage profiles

The **plotCC()** function accepts our list of ChIPQC sample objects and a **facetBy** argument to allow us to group our cross-coverage profiles.

```{r qcmetridedecs,cache=FALSE,eval=TRUE,fig.width=6,fig.height=4}
plotCC(myQC,facetBy = "Sample")
```

---

## Cross-coverage plot

We can include additional metadata to allow us to group our plot in different ways.

We can include metadata as a data.frame where the first column is our sample names.


```{r qcmetridecs,cache=FALSE,eval=TRUE}
myMeta <- data.frame(Sample= names(myQC),
                     Tissue=c("Ch12","Ch12","MEL","MEL","MEL","Ch12"),
                     Antibody=c(rep("Myc",4),rep("Input",2)))
myMeta
```

---
## Cross-coverage plot

We can now include our metadata to the **addMetaData** argument which will allow us to **facetBy** the supplied metadata columns.

Additionally here we use the **colourBy** parameter to add colour to antibody groups.

```{r qcmetricsede,cache=FALSE,eval=TRUE,fig.width=6,fig.height=3}
plotCC(myQC,facetBy = "Tissue",addMetaData = myMeta,
       colourBy="Antibody")
```

---
## Cross-coverage plot

All plots in ChIPQC are in fact built in ggplot2 so we can edit and update our plot like all ggplot objects.

```{r qcmetricsrf,cache=FALSE,eval=TRUE,fig.width=6,fig.height=3}
plotCC(myQC,facetBy = "Tissue",addMetaData = myMeta,
       colourBy="Antibody")+theme_bw()+
  ggtitle("ChIPQC results")
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Blacklists and SSD

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Blacklists and SSD

---
"    
  )
  
}

```

---
## Blacklists

ChIPseq will often show the presence of common artefacts, such as ultra-high signal regions. Such regions can confound peak calling, fragment length estimation and QC metrics. Anshul Kundaje created the DAC blacklist as a reference to help deal with these regions.

<div align="center">
<img src="imgs/blacklist.png" alt="offset" height="500" width="400">
</div>

---
## Blacklist affects many metrics

<div align="center">
<img src="imgs/blacklistsAffects.jpg" alt="offset" height="400" width="400">
</div>

---
## Blacklists and SSD

SSD is one of these measures that is sensitive to blacklisted artefacts. SSD is a measure of standard deviation of signal across the genome with higher scores reflecting significant pile-up of reads. SSD can therefore be used to assess both the extent of ultra high signals and the signal. But first blacklisted regions must be removed.

<div align="center">
<img src="imgs/ssdAndBlacklist.png" alt="offset" height="400" width="300">
</div>

---
## Standardised Standard Deviation

ChIPQC calculates SSD before and after removing signal coming from Blacklisted regions.

The **plotSSD()** function plots samples's pre-blacklisting score in **red** and post-blacklisting score in **blue**.

Higher scores for pre-blacklisted SSD can suggest a strong background signal in blacklisted regions for that sample.

```{r fig.width=6,fig.height=2,warning=FALSE,message=FALSE}
plotSSD(myQC)+xlim(0,5)
```

---
## Standardised Standard Deviation

Since SSD score is strongly affected by blacklisting it may be necessary to change the axis to see any differences between samples for post-blacklisting scores.

Higher post-blacklisted SSD scores reflect samples with stronger peak signal.

```{r fig.width=6,fig.height=3,warning=FALSE,message=FALSE}
plotSSD(myQC)+xlim(0.2,0.8)
```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Library complexity and enrichment

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Library complexity and enrichment

---
"    
  )
  
}

```

---
## Library complexity

A potential source of noise in ChIPseq is overamplification of the ChIPseq library during a PCR step. This can lead to large number of duplicate reads which may confound peak calling.

![](imgs/mappable.png)

---
## Duplication

We should compare our duplication rate across samples to identify any sample experiencing overamplification and so potential of a lower complexity.

The **flagtagcounts()** function reports can report the number of duplicates and total mapped reads and so from there we can calculate our duplication rate.

```{r fig.width=6,fig.height=3,warning=FALSE,message=FALSE}
myFlags <- flagtagcounts(myQC)
myFlags["DuplicateByChIPQC",]/myFlags["Mapped",]
```


---
## Enrichment for reads across genes.

We can also use ChIPQC to review where our distribution of reads across gene features using the **plotRegi()** function.

Here we expect ChIPseq signal to be stronger in 5'UTRs and promoters when compared to input samples.

```{r warning=FALSE,message=FALSE,fig.width=8,fig.height=4}
p <- plotRegi(myQC)
```

---
## Enrichment for reads across genes.

```{r warning=FALSE,fig.width=12,fig.height=6}
p
```


---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Peak Calling

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Peak Calling

---
"    
  )
  
}

```

---
## Peak calling

To identify regions of Myc transcription factor binding we can use a **peak caller**.

Although peak caller are available in R (including our own), the most popular and widely used peak called remains **MACS2**.

MACS2 calls peaks in a few simple steps.

* Predict fragment length.
* Shift reads to centre of predicted fragment.
* Scan across genome and identify regions enriched compare to control samples using count based statistic.

---
## Installing MACS2

Though this software is not directly available in R we can use the tools we used to install Salmon to get MACS2. 

* Install conda with **[Anaconda](https://anaconda.org/)** or **[Miniconda](https://conda.io/miniconda.html)**

![testing](imgs/bioconda.jpg)


* Set bioconda channels according to the *[construction](https://bioconda.github.io/index.html#set-up-channels)*

* Install packages e.g. *[MACS2](https://bioconda.github.io/recipes/macs2/README.html)*



---
## Running MACS2

To run MACS2 to we simply need to supply.

* A BAM file to find enriched regions in. (specified after **-t**)
* A Name for peak calls (specified after **–name**).
* An output folder to write peaks into (specified after **–outdir**).
* Optionally, but highly recommended, we can identify a control to compare to (specified after **–c**).

```{r , engine='bash', eval=FALSE}
macs2 callpeak -t Sorted_Myc_MEL_1.bam
               –name Mel_Rep1 
               –-outdir PeakDirectory
               -c Sorted_Input_MEL.bam 

```
---
## Running MACS2 in R

We can still run our MACS2 from the comfort of R using the **system()** function.

We simply need to build our MACS2 peak call command in R and pass to the **system()** function. 

```{r fig.height=5, fig.width=15,eval=FALSE}
myChIP <- "Sorted_Myc_MEL_1.bam"
myControl <- "Sorted_Input_MEL.bam"

macsCommand <- paste0("macs2 callpeak -t ", myChIP,
                      " -n ", "Mel_Rep1",
                      " –-outdir ","PeakDirectory",
                      " -c ", myControl)
system(macsCommand)
```



---
## Working with Peaks

MACS peak calls can be found in our specied output directory with the suffix and extension "_peaks.xls".

MACS peaks come as a tab seperated file thinly disguised as a ".xls".

In addition to the genomic coordinates of peaks, these files contain useful information on the samples, parameters and version used for peak calling at the top.

```{r,eval=T,echo=F,  warning=FALSE,collapse=T}
macsPeaks <- "data/Mel1_peaks.xls"
```

```{r,eval=T,echo=F,  warning=FALSE,collapse=T}
macsPeaks_DF <- read.delim(macsPeaks)
macsPeaks_DF[1:8,]
```

---
## Importing MACS peaks

We can import peak files therefore using read.delim function. Note we have set *comment.char* argument to **#** to exclude additional information on peak calling parameters stored within the MACS peak file.

```{r,eval=F,echo=T,  warning=FALSE,collapse=T}
macsPeaks <- "data/Mel1_peaks.xls"
```

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
macsPeaks_DF <- read.delim(macsPeaks, comment.char="#")
macsPeaks_DF[1:2,]
```

---
## Converting MACS peaks

Now we have the information in a table we can create a GRanges object.

GRanges objects are made of chromosome names and intervals stored as IRanges.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
library(GenomicRanges)
macsPeaks_GR <- GRanges(
 seqnames=macsPeaks_DF[,"chr"],
 IRanges(macsPeaks_DF[,"start"],
         macsPeaks_DF[,"end"]
 )
)
macsPeaks_GR
```

---
## Peaks as GRanges


As we have seen before elements in GRanges can accessed and set using various GRanges functions.
Here we can deconstruct our object back to contig names and interval ranges.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
seqnames(macsPeaks_GR)
ranges(macsPeaks_GR)
```

---
## Peaks as GRanges

GRanges objects may have metadata attached. Here we attach some useful information on our peaks including the summit position and the fold enrichment over input.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
mcols(macsPeaks_GR) <- macsPeaks_DF[,c("abs_summit", "fold_enrichment")]
macsPeaks_GR
```


---
## Filter peaks in blacklisted regions

We will want to remove any peaks overlapping blacklisted regions prior to any downstream analysis. 
We can do this using simple overlapping with GRanges objects.


```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE}
library(rtracklayer)
blkList <- import.bed(toBlkList)
macsPeaks_GR <- macsPeaks_GR[!macsPeaks_GR %over% blkList] 
```



---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides == "yes"){
  cat("class: inverse, center, middle

# Peak Annotation

<html><div style='float:left'></div><hr color='#EB811B' size=1px width=720px></html> 

---
"    
  )
}else{
  cat("# Peak Annotation

---
"    
  )
  
}

```

---

## Annotation of peaks to genes

So far we have been working with ChIPseq peaks corresponding to transcription factor binding. Transcription factors, as implied in the name, can affect the expression of their target genes.

The target of transcription factor is hard to assertain from ChIPseq data alone and so often we will annotate peaks to genes by a simple set of rules:-

Peaks are typically annotated to a gene if
* They overlap the gene.
* The gene is the closest (and within a minimum distance).



---

## Peak annotation


A useful package for annotation of peaks to genes is **ChIPseeker**. 

By using pre-defined annotation in the from of a **TXDB** object for mouse (mm10 genome), ChIPseeker will provide us with an overview of where peaks land in the gene and distance to TSS sites.

First load the libraries we require for the next part.

```{r,include=FALSE}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(org.Mm.eg.db)
library(GenomeInfoDb)
library(ChIPseeker)

```

```{r,eval=F,echo=T, eval=T, echo=T, warning=FALSE,tidy=T,message=FALSE}
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(org.Mm.eg.db)
library(GenomeInfoDb)
library(ChIPseeker)

```

---

## Peak annotation


The annotatePeak function accepts a GRanges object of the regions to annotate, a TXDB object for gene locations and a database object name to retrieve gene names from.


```{r,eval=T,echo=T, message=FALSE,messages=FALSE, eval=T, echo=T, warning=FALSE}
peakAnno <- annotatePeak(macsPeaks_GR, tssRegion=c(-500, 500), 
                         TxDb=TxDb.Mmusculus.UCSC.mm10.knownGene, 
                         annoDb="org.Mm.eg.db")
class(peakAnno)
```
---
## Peak annotation

The result is a csAnno object containing annotation for peaks and overall annotation statistics.

```{r,eval=T,echo=T, message=F,messages=F, eval=T, echo=T, warning=FALSE,tidy=T}
peakAnno
```

---
## Peak annotation


The csAnno object contains the information on annotation of individual peaks to genes.

To extract this from the csAnno object the ChIPseeker functions *as.GRanges* or *as.data.frame* can be used to produce the respective object with peaks and their associated genes.

```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
peakAnno_GR <- as.GRanges(peakAnno)
peakAnno_DF <- as.data.frame(peakAnno)
```

---
## Peak annotation
```{r,eval=T,echo=T, eval=T, echo=T, warning=FALSE,tidy=T}
peakAnno_GR[1,]
```

---
## Vizualising peak annotation

Now we have the annotated peaks from ChIPseeker we can use some of ChIPseeker's plotting functions to display distribution of peaks in gene features. Here we use the **plotAnnoBar** function to plot this as a bar chart but  **plotAnnoPie** would produce a similar plot as a pie chart.


```{r, eval=T, echo=T, fig.height=5, fig.width=15, warning=FALSE, tidy=T}
plotAnnoBar(peakAnno)
```

---
## Vizualising peak annotation

Similarly we can plot the distribution of peaks around TSS sites.


```{r,eval=T,echo=T, eval=F, echo=T, warning=FALSE,fig.height=5, fig.width=15,tidy=T}
plotDistToTSS(peakAnno)
```

![](imgs/TSS1.png)

---
# Visualising peak annotation

ChIPseeker can also offer a succinct plot to describe the overlap between annotations.


```{r, eval=T, echo=T, fig.height=5, fig.width=15, warning=FALSE, tidy=T}
upsetplot(peakAnno, vennpie=F)
```


---
## Time for an exercise!

Exercise on ChIP-seq data can be found [here](../../exercises/exercises/chipseq_part2_exercise.html)

---
## Answers to exercise

Answers can be found [here](../../exercises/answers/chipseq_part2_answers.html)

R code for solutions can be found [here](../../exercises/answers/chipseq_part2_answers.R)




<!--chapter:end:ChIPseq_In_Bioconductor2.Rmd-->

