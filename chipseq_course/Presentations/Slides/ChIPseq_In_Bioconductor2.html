<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta charset="utf-8">
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# ChIP-seq In Bioconductor part2
<html>
<div style="float:left">

</div>
<hr color='#EB811B' size=1px width=796px>
</html>
### Rockefeller University, Bioinformatics Resource Centre
### <a href="http://rockefelleruniversity.github.io/Bioconductor_Introduction/" class="uri">http://rockefelleruniversity.github.io/Bioconductor_Introduction/</a>

---





# Data

In todays session we will continue to review the Myc ChIPseq we were working on in our last session.

This include Myc ChIP-seq for MEL and Ch12 celllines as well as their input controls.

Information and files for the [Myc ChIPseq in MEL cell line can be found here](https://www.encodeproject.org/experiments/ENCSR000EUA/)

Information and files for the [Myc ChIPseq in Ch12 cell line can be found here](https://www.encodeproject.org/experiments/ENCSR000ERN/)

Input control can be found for [MEL cell line can be found here](https://www.encodeproject.org/experiments/ENCSR000EUA/)

Input control can be found for [Ch12 cell line can be found here.](https://www.encodeproject.org/experiments/ENCSR000ERN/)




---
# Quality Control.


ChIP-seq has many sources of potential noise including 
* Varying efficiency of antibodies
* Non-specific binding
* Library complexity
* ChIP artefacts and background.

Many of these sources of noise can be assessed using some now well-established methodology.

---

# Quality Control. - Some references


For some discussions:

* Encode quality metrics.

[Large-scale quality analysis of published ChIP-seq data. Marinov GK, Kundaje A, Park PJ, Wold BJ. G3 (Bethesda). 2014 Feb 19;4(2)](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3931556/)

* Overestimation of artefact duplicates in ChIPseq.

[Systematic evaluation of factors influencing ChIP-seq fidelity.Nat Methods. Chen Y, Negre N, Li Q, Mieczkowska JO, Slattery M, Liu T, Zhang Y, Kim TK, He HH, Zieba J, Ruan Y, Bickel PJ, Myers RM, Wold BJ, White KP, Lieb JD, Liu XS. 2012 Jun;9(6)](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3477507/)


* When and what QC is useful.

[Impact of artifact removal on ChIP quality metrics in ChIP-seq and ChIP-exo data.Front Genet. 2014 Apr 10;5:75.Carroll TS, Liang Z, Salama R, Stark R, de Santiago I](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3989762/)

---
# Quality Control - Always have an appropriate input.


* Input samples are typically made from fragmented DNA prior to IP enrichment.

* Allows for control of artefact regions which occur across samples.

* NEVER run ChIP-seq without considering which input to use.

e.g. When using tumour samples for ChIP-seq, it is important to have matched input samples. 
Differing conditions of same tissue may share common input. 
---
# Quality Control - Quality metrics for ChIP-seq.


The [**ChIPQC package**](https://bioconductor.org/packages/release/bioc/html/ChIPQC.html) wraps some of the metrics into a Bioconductor package and takes care to measure these metrics under the appropriate condition. 

To run a single sample we can use the **ChIPQCsample()** function, the relevant **unfiltered** BAM file and we are recommended to supply a **blacklist** as a BED file or GRanges and Genome name.

You can find a Blacklist for most genomes at [Anshul Kundaje's site](https://sites.google.com/site/anshulkundaje/projects/blacklists) or directly from the [Encode websites](https://www.encodeproject.org/annotations/ENCSR636HFF/)





```r
QCresult &lt;- ChIPQCsample(reads="/pathTo/myChIPreads.bam",
                         genome="mm10",
                         blacklist = "/pathTo/mm10_Blacklist.bed")
```

---
# Quality control

We download the blacklist for mm10 from [Encode ](https://www.encodeproject.org/files/ENCFF547MET/@@download/ENCFF547MET.bed.gz)

We can then provide an initial analysis of our ChIP-seq samples quality using the **ChIPQCsample()** function from the [**ChIPQC** package.](http://bioconductor.org/packages/stats/bioc/ChIPQC/).

Here we evalute the quality of samples we aligned with Rsubread last week. The returned object is a **ChIPQCsample** object.


```r
library(ChIPQC)
chipqc_MycMel_rep1 &lt;- ChIPQCsample("SR_Myc_Mel_rep1.bam",
                         annotation = "mm10",
                         blacklist = toBlkList,
                         chromosomes = paste0(c("chr",1:10)))
class(chipqc_MycMel_rep1)
```


```
## [1] "ChIPQCsample"
## attr(,"package")
## [1] "ChIPQC"
```

---
# Quality control

We can display our **ChIPQCsample** object which will show a basic summary of our ChIP-seq quality.




```r
chipqc_MycMel_rep1
```

```
## 					ChIPQCsample
```

```
## Number of Mapped reads: 17434045
```

```
## Number of Mapped reads passing MapQ filter: 14027340
```

```
## Percentage Of Reads as Non-Duplicates (NRF): 100(0)
```

```
## Percentage Of Reads in Blacklisted Regions: 6
```

```
## SSD: 2.04563248560836
```

```
## Fragment Length Cross-Coverage: 0.00240586015883558
```

```
## Relative Cross-Coverage: 1.36747914104688
```

```
## Percentage Of Reads in GenomicFeature:
```

```
##                         ProportionOfCounts
## BlackList                       0.06945900
## LongPromoter20000to2000         0.25996440
## Promoters2000to500              0.04602540
## Promoters500                    0.04435780
## All5utrs                        0.02186480
## Alltranscripts                  0.56982008
## Allcds                          0.02862382
## Allintrons                      0.51979606
## All3utrs                        0.02149253
```

```
## Percentage Of Reads in Peaks: NA
```

```
## Number of Peaks: 0
```

```
## GRanges object with 0 ranges and 0 metadata columns:
##    seqnames    ranges strand
##       &lt;Rle&gt; &lt;IRanges&gt;  &lt;Rle&gt;
##   -------
##   seqinfo: no sequences
```

---
# Quality control

It is best to review ChIP-seq quality versus your input controls and other Myc samples which we are using (or even external data if you do not have your own).

This will allow us to identify expected patterns of ChIP-seq enrichment in our samples versus controls as well as spot any outlier samples by these metrics.

We can run **ChIPQCsample()** on all our samples of interest using an **lapply**.




```r
bamsToQC &lt;- c("Sorted_Myc_Ch12_1.bam","Sorted_Myc_Ch12_2.bam",
             "Sorted_Myc_MEL_1.bam","Sorted_Myc_MEL_2.bam",
             "Sorted_Input_MEL.bam","Sorted_Input_Ch12.bam")
myQC &lt;- bplapply(bamsToQC,ChIPQCsample,
        annotation = "mm10",
        blacklist = toBlkList,
        chromosomes = paste0("chr",1:10))
names(myQC) &lt;- bamsToQC
```

---
# Quality control

All ChIPQC functions can work with a named list of **ChIPQCsample** objects to aggregate scores into table as well as plots.

Here we use the **QCmetrics()** function to ive an overview of quality metrics. 




```r
QCmetrics(myQC)
```

```
##                          Reads Map% Filt% Dup% ReadL FragL RelCC  SSD RiP%
## Sorted_Myc_Ch12_1.bam 10993821  100  21.9    0    35   186 1.070 3.82   NA
## Sorted_Myc_Ch12_2.bam 10060460  100  18.4    0    35   146 1.310 2.84   NA
## Sorted_Myc_MEL_1.bam  10111080  100  20.8    0    35   177 1.220 3.42   NA
## Sorted_Myc_MEL_2.bam  10686984  100  23.4    0    35   177 1.050 4.20   NA
## Sorted_Input_MEL.bam   8591703  100  23.6    0    36   184 0.620 4.51   NA
## Sorted_Input_Ch12.bam 10429244  100  23.7    0    35   182 0.275 4.26   NA
##                       RiBL%
## Sorted_Myc_Ch12_1.bam  12.8
## Sorted_Myc_Ch12_2.bam  10.1
## Sorted_Myc_MEL_1.bam   11.9
## Sorted_Myc_MEL_2.bam   14.0
## Sorted_Input_MEL.bam   15.9
## Sorted_Input_Ch12.bam  12.8
```

---

# Quality Control (Assessing fragment length)


The prediction of fragment length is an essential part of ChIP-seq affecting peaks calling, summit identification and coverage profiles. 

The use of cross-correlation or cross-coverage allows for an assessment of reads clustering by strand and so a measure of quality. 

---
# Quality Control (Assessing fragment length)

&lt;div align="center"&gt;
&lt;img src="imgs/ChIP-seq_biology_slides.png" alt="offset" height="400" width="600"&gt;
&lt;/div&gt;

---

# Quality Control (Assessing fragment length)

* In ChIP-seq typically short single end reads of dsDNA.

* **dsDNA single end sequencing means**
+ 5' of fragment will be sequenced on "+" strand
+ 3' of fragment end will be on "-" strand.

* **Although we only have partial sequence of strand, with predicted fragment length we can predicted the whole fragment**
+ "+" reads should extend only in positive direction 
+ "-" reads only in negative

---

# Quality Control (Assessing fragment length)

&lt;div align="center"&gt;
&lt;img src="imgs/pileup.png" alt="offset" height="500" width="400"&gt;
&lt;/div&gt;

---

# Quality Control (Assessing fragment length)

&lt;div align="center"&gt;
&lt;img src="imgs/offset.jpg" alt="offset" height="500" width="400"&gt;
&lt;/div&gt;

---

# Quality Control (Assessing fragment length)

&lt;div align="center"&gt;
&lt;img src="imgs/shifts.gif" alt="offset" height="200" width="700"&gt;
&lt;/div&gt;
&lt;div align="center"&gt;
&lt;img src="imgs/cor.gif" alt="offset" height="300" width="700"&gt;
&lt;/div&gt;

---

# Quality Control (Assessing fragment length)

&lt;div align="center"&gt;
&lt;img src="imgs/shifts.jpg" alt="offset" height="500" width="400"&gt;
&lt;/div&gt;

---

# Quality Control (Assessing fragment length)
The **plotCC** function can be used to plot our cross-coverage profiles

The **plotCC()** function accepts our list of ChIPQC sample objects and a **facetBy** argument to allow us to group our cross-coverage profiles.


```r
plotCC(myQC,facetBy = "Sample")
```

![](ChIPseq_In_Bioconductor2_files/figure-html/qcmetridedecs-1.png)&lt;!-- --&gt;

---

# Quality Control (Assessing fragment length)

We can include additional metadata to allow us to group our plot in different ways.

We can include metadata as a data.frame where the first column is our sample names.



```r
myMeta &lt;- data.frame(Sample= names(myQC),
                     Tissue=c("Ch12","Ch12","MEL","MEL","MEL","Ch12"),
                     Antibody=c(rep("Myc",4),rep("Input",2)))
myMeta
```

```
##                  Sample Tissue Antibody
## 1 Sorted_Myc_Ch12_1.bam   Ch12      Myc
## 2 Sorted_Myc_Ch12_2.bam   Ch12      Myc
## 3  Sorted_Myc_MEL_1.bam    MEL      Myc
## 4  Sorted_Myc_MEL_2.bam    MEL      Myc
## 5  Sorted_Input_MEL.bam    MEL    Input
## 6 Sorted_Input_Ch12.bam   Ch12    Input
```

---
# Quality Control (Assessing fragment length)

We can now include our metadata to the **addMetaData** argument which will allow us to **facetBy** the supplied metadata columns.

Additionally here we use the **colourBy** parameter to add colour to antibody groups.


```r
plotCC(myQC,facetBy = "Tissue",addMetaData = myMeta,
       colourBy="Antibody")
```

![](ChIPseq_In_Bioconductor2_files/figure-html/qcmetricsede-1.png)&lt;!-- --&gt;
---
# Quality Control (Assessing fragment length)

All plots in ChIPQC are in fact built in ggplot2 so we can edit and update our plot like all ggplot objects.


```r
plotCC(myQC,facetBy = "Tissue",addMetaData = myMeta,
       colourBy="Antibody")+theme_bw()+
  ggtitle("ChIPQC results")
```

![](ChIPseq_In_Bioconductor2_files/figure-html/qcmetricsrf-1.png)&lt;!-- --&gt;


---
# Quality Control - Blacklists and SSD.


ChIP-seq will often show the presence of common artefacts such as ultra-high signal regions or **Blacklists**. Such regions can confound peak calling, fragment length estimation and QC metrics.

SSD is a measure of standard deviation of signal across the genome with higher scores reflecting significant pile-up of reads. SSD can therefore be used to assess both the extent of ultra high signals and the signal following removal of these blacklisted regions.

For a note on known Blacklisted regions and on associated resources.
* [Blacklisted Regions](http://mrccsc.github.io/analysisbeginings.html#/35)

For a note on SSD
* [SSD and Signal Pileup](http://mrccsc.github.io/analysisbeginings.html#/36).

---
# Quality Control - Blacklist???

&lt;div align="center"&gt;
&lt;img src="imgs/blacklist.png" alt="offset" height="500" width="400"&gt;
&lt;/div&gt;

---
# Quality Control - Blacklist affects many metrics.


&lt;div align="center"&gt;
&lt;img src="imgs/blacklistsAffects.jpg" alt="offset" height="400" width="400"&gt;
&lt;/div&gt;

---
# Quality Control - Blacklist affects many metrics.


&lt;div align="center"&gt;
&lt;img src="imgs/ssdAndBlacklist.png" alt="offset" height="400" width="300"&gt;
&lt;/div&gt;


---
# Quality Control - Standardised Standard Deviation.


ChIPQC calculates SSD before and after removing signal coming from Blacklisted regions.

The **plotSSD()** function plots samples's pre-blacklisting score in **red** and post-blacklisting score in **blue**.

Higher scores for pre-blacklisted SSD can suggest a strong background signal in blacklisted regions for that sample.


```r
plotSSD(myQC)+xlim(0,5)
```

![](ChIPseq_In_Bioconductor2_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---
# Quality Control - Standardised Standard Deviation.


Since SSD score is strongly affected by blacklisting it may be necessary to change the axis to see any differences between samples for post-blacklisting scores.

Higher post-blacklisted SSD scores reflect samples with stronger peak signal.


```r
plotSSD(myQC)+xlim(0.2,0.4)
```

![](ChIPseq_In_Bioconductor2_files/figure-html/unnamed-chunk-3-1.png)&lt;!-- --&gt;

---
# Quality Control - Library complexity

A potential source of noise in ChIPseq is overamplification of the ChIP-seq library during a PCR step. This can lead to large number of duplicate reads which may confound peak calling.

![](imgs/mappable.png)

---
# Quality Control - Duplication.


We should compare our duplication rate across samples to identify any sample experiencing overamplification and so potential of a lower complexity.

The **flagtagcounts()** function reports can report the number of duplicates and total mapped reads and so from there we can calculate our duplication rate.


```r
myFlags &lt;- flagtagcounts(myQC)
myFlags["DuplicateByChIPQC",]/myFlags["Mapped",]
```

```
## Sorted_Myc_Ch12_1.bam Sorted_Myc_Ch12_2.bam  Sorted_Myc_MEL_1.bam 
##            0.07203883            0.08633293            0.15987076 
##  Sorted_Myc_MEL_2.bam  Sorted_Input_MEL.bam Sorted_Input_Ch12.bam 
##            0.06253850            0.14269010            0.13873057
```


---
# Quality Control - Enrichment for reads across genes.

We can also use ChIPQC to review where our distribution of reads across gene features using the **plotRegi()** function.

Here we expect ChIPseq signal to be stronger in 5'UTRs and promoters when compared to input samples.


```r
p &lt;- plotRegi(myQC)
```

---
# Quality Control - Enrichment for reads across genes.


```r
p
```

![](ChIPseq_In_Bioconductor2_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;


---
# Peak calling

To identify regions of Myc transcription factor binding we can use a **peak caller**.

Although peak caller are available in R (including our own), the most popular and widely used peak called remains **MACS2**.

MACS2 calls peaks in a few simple steps.

* Predict fragment length.
* Shift reads to centre of predicted fragment.
* Scan across genome and identify regions enriched compare to control samples using count based statistic.

---
# Peak calling (Installing MACS2)

![testing](imgs/bioconda.jpg){width=50%}

* Install conda with **[Anaconda](https://anaconda.org/)** or **[Miniconda](https://conda.io/miniconda.html)**


* Set bioconda channels accroding to the *[construction](https://bioconda.github.io/index.html#set-up-channels)*

* Install packages e.g. *[MACS2](https://bioconda.github.io/recipes/macs2/README.html)*



---
# Peak calling (Running MACS2)

To run MACS2 to we simply need to supply.

* A BAM file to find enriched regions in. (specified after **-t**)
* A Name for peak calls (specified after **–name**).
* An output folder to write peaks into (specified after **–outdir**).
* Optionally, but highly recommended, we can identify a control to compare to (specified after **–c**).


```bash
macs2 callpeak -t Sorted_Myc_MEL_1.bam
               –name Mel_Rep1 
               –-outdir PeakDirectory
               -c Sorted_Input_MEL.bam 

```
---
# Peak calling from R

We can still run our MACS2 from the comfort of R using the **system()** function.

We simply need to build our MACS2 peak call command in R and pass to the **system()** function. 


```r
myChIP &lt;- "Sorted_Myc_MEL_1.bam"
myControl &lt;- "Sorted_Input_MEL.bam"

macsCommand &lt;- paste0("macs2 callpeak -t ", myChIP,
                      " -n ", "Mel_Rep1",
                      " –-outdir ","PeakDirectory",
                      " -c ", myControl)
system(macsCommand)
```



---
# Working with Peaks


MACS peak calls can be found in our specied output directory with the suffix and extension "_peaks.xls".

MACS peaks come as a tab seperated file thinly disguised as a ".xls".


```
##    chr   start     end length abs_summit pileup X.log10.pvalue.
## 1 chr1 4785371 4785642    272    4785563  20.89        10.66553
## 2 chr1 5082993 5083247    255    5083123  33.42        12.68072
## 3 chr1 7397544 7398115    572    7397837  34.26        26.16516
##   fold_enrichment X.log10.qvalue.        name
## 1         5.33590         7.37727 Mel1_peak_1
## 2         4.30257         9.27344 Mel1_peak_2
## 3         9.58306        22.20383 Mel1_peak_3
```

---
#Working with Peaks


In addition to the genomic coordinates of peaks, these files contain useful information on the samples, parameters and version used for peak calling at the top.


```
## [1] "# Command line: callpeak -t Sorted_Myc_MEL_1.bam -n Mel1 -c Sorted_Input_MEL.bam"
## [2] "# ARGUMENTS LIST:"                                                               
## [3] "# name = Mel1"                                                                   
## [4] "# format = AUTO"                                                                 
## [5] "# ChIP-seq file = ['Sorted_Myc_MEL_1.bam']"                                      
## [6] "# control file = ['Sorted_Input_MEL.bam']"                                       
## [7] "# effective genome size = 2.70e+09"                                              
## [8] "# band width = 300"
```

---

# Working with Peaks - Importing peaks


We can import peak files therefore using read.delim function. Note we have set *comment.char* argument to **#** to exclude additional information on peak calling parameters stored within the MACS peak file.


```r
macsPeaks_DF &lt;- read.delim(macsPeaks,comment.char="#")
macsPeaks_DF[1:2,]
```

```
##    chr   start     end length abs_summit pileup X.log10.pvalue.
## 1 chr1 4785371 4785642    272    4785563  20.89        10.66553
## 2 chr1 5082993 5083247    255    5083123  33.42        12.68072
##   fold_enrichment X.log10.qvalue.        name
## 1         5.33590         7.37727 Mel1_peak_1
## 2         4.30257         9.27344 Mel1_peak_2
```

---
# Working with Peaks - Importing peaks


Now we have the information in a table we can create a GRanges object.

GRanges objects are made of chromosome names and intervals stored as IRanges.


```r
library(GenomicRanges)
macsPeaks_GR &lt;- GRanges(
 seqnames=macsPeaks_DF[,"chr"],
 IRanges(macsPeaks_DF[,"start"],
         macsPeaks_DF[,"end"]
 )
)
macsPeaks_GR
```

```
## GRanges object with 16757 ranges and 0 metadata columns:
##           seqnames               ranges strand
##              &lt;Rle&gt;            &lt;IRanges&gt;  &lt;Rle&gt;
##       [1]     chr1   [4785371, 4785642]      *
##       [2]     chr1   [5082993, 5083247]      *
##       [3]     chr1   [7397544, 7398115]      *
##       [4]     chr1   [7616290, 7616433]      *
##       [5]     chr1   [8134747, 8134893]      *
##       ...      ...                  ...    ...
##   [16753]     chrY [ 2657144,  2657294]      *
##   [16754]     chrY [90784142, 90784289]      *
##   [16755]     chrY [90818471, 90818771]      *
##   [16756]     chrY [90824549, 90824905]      *
##   [16757]     chrY [90825407, 90825575]      *
##   -------
##   seqinfo: 21 sequences from an unspecified genome; no seqlengths
```

---
# Working with Peaks - Peaks as GRanges


As we have seen before elements in GRanges can accessed and set using various GRanges functions.
Here we can deconstruct our object back to contig names and interval ranges.


```r
seqnames(macsPeaks_GR)
```

```
## factor-Rle of length 16757 with 21 runs
##   Lengths:   916   822  1795   582   596 ...  1089   836   954   395     7
##   Values :  chr1 chr10 chr11 chr12 chr13 ...  chr7  chr8  chr9  chrX  chrY
## Levels(21): chr1 chr10 chr11 chr12 chr13 ... chr7 chr8 chr9 chrX chrY
```

```r
ranges(macsPeaks_GR)
```

```
## IRanges object with 16757 ranges and 0 metadata columns:
##               start       end     width
##           &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
##       [1]   4785371   4785642       272
##       [2]   5082993   5083247       255
##       [3]   7397544   7398115       572
##       [4]   7616290   7616433       144
##       [5]   8134747   8134893       147
##       ...       ...       ...       ...
##   [16753]   2657144   2657294       151
##   [16754]  90784142  90784289       148
##   [16755]  90818471  90818771       301
##   [16756]  90824549  90824905       357
##   [16757]  90825407  90825575       169
```

---
# Working with Peaks - Peaks as GRanges


GRanges objects may have metadata attached. Here we attach some useful information on our peaks including the summit position and the fold enrichment over input.


```r
mcols(macsPeaks_GR) &lt;- macsPeaks_DF[,c("abs_summit", "fold_enrichment")]
macsPeaks_GR
```

```
## GRanges object with 16757 ranges and 2 metadata columns:
##           seqnames               ranges strand | abs_summit
##              &lt;Rle&gt;            &lt;IRanges&gt;  &lt;Rle&gt; |  &lt;integer&gt;
##       [1]     chr1   [4785371, 4785642]      * |    4785563
##       [2]     chr1   [5082993, 5083247]      * |    5083123
##       [3]     chr1   [7397544, 7398115]      * |    7397837
##       [4]     chr1   [7616290, 7616433]      * |    7616380
##       [5]     chr1   [8134747, 8134893]      * |    8134873
##       ...      ...                  ...    ... .        ...
##   [16753]     chrY [ 2657144,  2657294]      * |    2657196
##   [16754]     chrY [90784142, 90784289]      * |   90784227
##   [16755]     chrY [90818471, 90818771]      * |   90818595
##   [16756]     chrY [90824549, 90824905]      * |   90824771
##   [16757]     chrY [90825407, 90825575]      * |   90825485
##           fold_enrichment
##                 &lt;numeric&gt;
##       [1]          5.3359
##       [2]         4.30257
##       [3]         9.58306
##       [4]          7.6586
##       [5]         2.94486
##       ...             ...
##   [16753]         4.25981
##   [16754]         6.91704
##   [16755]         5.63525
##   [16756]         5.21309
##   [16757]         3.09097
##   -------
##   seqinfo: 21 sequences from an unspecified genome; no seqlengths
```


---
# Working with Peaks - Filter peaks in blacklisted regions.

We will want to remove any peaks overlapping blacklisted regions prior to any downstream analysis. 
We can do this using simple overlapping with GRanges objects.



```r
library(rtracklayer)
blkList &lt;- import.bed("mm10-blacklist.bed")
macsPeaks_GR &lt;- macsPeaks_GR[!macsPeaks_GR %over% blkList] 
```

---

# Annotation of peaks to genes

So far we have been working with ChIP-seq peaks corresponding to transcription factor binding. Transcription factors, as implied in the name, can affect the expression of their target genes.

The target of transcription factor is hard to assertain from ChIP-seq data alone and so often we will annotate peaks to genes by a simple set of rules:-

Peaks are typically annotated to a gene if
* They overlap the gene.
* The gene is the closest (and within a minimum distance.)



---

# Peak annotation


A useful package for annotation of peaks to genes is **ChIPseeker**. 

By using pre-defined annotation in the from of a **TXDB** object for mouse (mm9 genome), ChIPseeker will provide us with an overview of where peaks land in the gene and distance to TSS sites.

First load the libraries we require for the next part.




```r
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(org.Mm.eg.db)
library(GenomeInfoDb)
library(ChIPseeker)
```

---

# Peak annotation


The annotatePeak function accepts a GRanges object of the regions to annotate, a TXDB object for gene locations and a database object name to retrieve gene names from.



```r
peakAnno &lt;- annotatePeak(macsPeaks_GR, tssRegion=c(-500, 500), 
                         TxDb=TxDb.Mmusculus.UCSC.mm10.knownGene, 
                         annoDb="org.Mm.eg.db")
```

```
## &gt;&gt; preparing features information...		 2018-12-02 11:41:47 
## &gt;&gt; identifying nearest features...		 2018-12-02 11:41:48 
## &gt;&gt; calculating distance from peak to TSS...	 2018-12-02 11:41:49 
## &gt;&gt; assigning genomic annotation...		 2018-12-02 11:41:49 
## &gt;&gt; adding gene annotation...			 2018-12-02 11:42:04 
## &gt;&gt; assigning chromosome lengths			 2018-12-02 11:42:04 
## &gt;&gt; done...					 2018-12-02 11:42:04
```

```r
class(peakAnno)
```

```
## [1] "csAnno"
## attr(,"package")
## [1] "ChIPseeker"
```
---
# Peak annotation


The result is a csAnno object containing annotation for peaks and overall annotation statistics.


```r
peakAnno
```

```
## Annotated peaks generated by ChIPseeker
## 16380/16380  peaks were annotated
## Genomic Annotation Summary:
##              Feature  Frequency
## 9           Promoter 35.7570208
## 4             5' UTR  0.6349206
## 3             3' UTR  1.6788767
## 1           1st Exon  1.0195360
## 7         Other Exon  2.4664225
## 2         1st Intron 13.7545788
## 8       Other Intron 16.8009768
## 6 Downstream (&lt;=3kb)  1.6666667
## 5  Distal Intergenic 26.2210012
```

---
#Peak annotation


The csAnno object contains the information on annotation of individual peaks to genes.

To extract this from the csAnno object the ChIPseeker functions *as.GRanges* or *as.data.frame* can be used to produce the respective object with peaks and their associated genes.


```r
peakAnno_GR &lt;- as.GRanges(peakAnno)
peakAnno_DF &lt;- as.data.frame(peakAnno)
```

---
#Peak annotation

```r
peakAnno_GR[1, ]
```

```
## GRanges object with 1 range and 14 metadata columns:
##       seqnames             ranges strand | abs_summit fold_enrichment
##          &lt;Rle&gt;          &lt;IRanges&gt;  &lt;Rle&gt; |  &lt;integer&gt;       &lt;numeric&gt;
##   [1]     chr1 [4785371, 4785642]      * |    4785563          5.3359
##        annotation   geneChr geneStart   geneEnd geneLength geneStrand
##       &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;  &lt;integer&gt;  &lt;integer&gt;
##   [1]    Promoter         1   4773200   4785726      12527          2
##            geneId transcriptId distanceToTSS            ENSEMBL
##       &lt;character&gt;  &lt;character&gt;     &lt;numeric&gt;        &lt;character&gt;
##   [1]       27395   uc007afd.3            84 ENSMUSG00000033845
##            SYMBOL                            GENENAME
##       &lt;character&gt;                         &lt;character&gt;
##   [1]      Mrpl15 mitochondrial ribosomal protein L15
##   -------
##   seqinfo: 21 sequences from mm10 genome
```

---
# Visualising peak annotation

Now we have the annotated peaks from ChIPseeker we can use some of ChIPseeker's plotting functions to display distribution of peaks in gene features. Here we use the **plotAnnoBar** function to plot this as a bar chart but  **plotAnnoPie** would produce a similar plot as a pie chart.



```r
plotAnnoBar(peakAnno)
```

![](ChIPseq_In_Bioconductor2_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

---
# Visualising peak annotation

Similarly we can plot the distribution of peaks around TSS sites.



```r
plotDistToTSS(peakAnno)
```

![](imgs/TSS1.png)

---
# Visualising peak annotation

ChIPseeker can also offer a succinct plot to describe the overlap between annotations.



```r
upsetplot(peakAnno, vennpie = F)
```

![](ChIPseq_In_Bioconductor2_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;


---

# Time for an exercise.

[Link_to_exercises](../../Exercises/chipseq_part2_exercises.html)

[Link_to_answers](../../Answers/chipseq_part2_answers.html)
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
